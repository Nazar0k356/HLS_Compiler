package TargetCodeGenerator;

import SyntaxDirectedTranslator.Translator;

import java.io.FileWriter;
import java.util.*;

public class CodeGenerator {
    public CodeGenerator(String targetCodeFileName, Translator syntaxDirectedTranslator){
        this.targetCodeFileName = targetCodeFileName;
        this.translator = syntaxDirectedTranslator;
    }
    //File, in which target code is outputted
    String targetCodeFileName;

    //Translator, which contains intermediate code
    Translator translator;

    //List of all standart integer registers
    String[] allRegisters = {"RAX", "RBX", "RCX", "RDX", "RDI", "RSI", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"};

    //List of all floating point registers
    String[] allFloatRegisters = {"XMM0", "XMM1", "XMM2", "XMM3", "XMM4", "XMM5", "XMM6", "XMM7",
            "XMM8", "XMM9", "XMM10", "XMM11", "XMM12", "XMM13", "XMM14", "XMM15"};

    //This list contains intermediate code, generated by syntax-directed translator
    public ArrayList<String[]> interCode;

    //The result code of code generation
    List<String> code = new ArrayList<>();

    //This hashmap represents registers: keys - registers, values - variables
    HashMap<String, String> registers = new HashMap<>();

    //This hashmap represents IEEE 754 (double) registers: keys - registers, values - variables
    HashMap<String, String> floatPointRegisters = new HashMap<>();

    //This hashmap indicates, if value is stored in memory
    HashMap<String, Boolean> inMemory = new HashMap<>();

    //This array stores information about usages of variables after each command, in which they are used
    HashMap<Integer,HashMap<String, Boolean>> usedLater = new HashMap<>();

    //This method outputs target code (assembly) into the file
    public boolean createTargetCode(){
        interCode = translator.translate();
        if(interCode == null){
            return false;
        }
        locateUsages(interCode);
        for(int commandNum = 0; commandNum < interCode.size(); commandNum++){
            String[] command = interCode.get(commandNum);
            String operand = command[0];
            switch(operand){
                case "=":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = "";
                    if(command[3].charAt(0) != '@'){
                        register2 = assignRegister(commandNum, 3);
                        inMemory.put(command[3], false);
                        String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                        if(register1.equals(register2)){
                            break;
                        }
                        if(type.equals("double")){
                            code.add("movsd "+register2+", "+register1);
                            floatPointRegisters.put(register2, command[3]);
                        } else {
                            code.add("mov "+register2+", "+register1);
                            registers.put(register2, command[3]);
                        }
                        break;
                    } else {
                        for(int i = 1; i < command[3].length(); i++){
                            register2 += command[3].charAt(i);
                        }
                    }
                    if(register1.equals(register2)){
                        break;
                    }
                    code.add("mov "+register2+", "+register1);
                    break;
                }
                case "+", "-", "*":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = prepareArgument(commandNum, 2);
                    String op = "";
                    String opFloat = "";
                    switch(operand){
                        case "+":{
                            op = "add";
                            opFloat = "addsd";
                            break;
                        }
                        case "-":{
                            op = "sub";
                            opFloat = "subsd";
                            break;
                        }
                        case "*":{
                            op = "imul";
                            opFloat = "mulsd";
                            break;
                        }
                    }
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add(op+" "+register1+", "+register2);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add(opFloat+" "+register1+", "+register2);
                        floatPointRegisters.put(register1, command[3]);
                    } else {
                        code.add(op+" "+register1+", "+register2);
                        registers.put(register1, command[3]);
                    }
                    inMemory.put(command[3], false);
                    break;
                }
                case "/":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = prepareArgument(commandNum, 2);
                    String label = translator.translation.newLabel();
                    String result = "";
                    if(command[3].charAt(0) == '@'){
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add("cmp "+register2+", 0");
                        code.add("jne "+label);
                        code.add("mov RAX, 1");
                        code.add("jmp finish");
                        code.add(label+":");
                        if(registers.get("RAX") != null){
                            saveVar(registers.get("RAX"));
                        }
                        if(registers.get("RDX") != null){
                            saveVar(registers.get("RDX"));
                        }
                        code.add("mov RDX, 0");
                        if(!register1.equals("RAX")){
                            code.add("mov RAX, "+register1);
                        }
                        code.add("idiv "+register2);
                        registers.remove("RDX");
                        if(!result.equals("RAX")){
                            code.add("mov "+result+", RAX");
                            registers.remove("RAX");
                        }
                        floatPointRegisters.put(result, command[3]);
                        break;
                    }
                    result = assignRegister(commandNum, 3);
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add("comisd "+register2+", 0");
                        code.add("jne "+label);
                        code.add("mov RAX, 1");
                        code.add("jmp finish");
                        code.add(label+":");
                        code.add("idiv "+register1+", "+register2);
                        registers.put(register1, command[3]);
                    } else {
                        code.add("cmp "+register2+", 0");
                        code.add("jne "+label);
                        code.add("mov RAX, 1");
                        code.add("jmp finish");
                        code.add(label+":");
                        if(registers.get("RAX") != null){
                            saveVar(registers.get("RAX"));
                        }
                        if(registers.get("RDX") != null){
                            saveVar(registers.get("RDX"));
                        }
                        code.add("mov RDX, 0");
                        if(!register1.equals("RAX")){
                            code.add("mov RAX, "+register1);
                        }
                        code.add("idiv "+register2);
                        registers.remove("RDX");
                        if(!result.equals("RAX")){
                            code.add("mov "+result+", RAX");
                            registers.remove("RAX");
                        }
                        registers.put(result, command[3]);
                    }
                    inMemory.put(command[3], false);
                    break;
                }
                case "AND", "OR", "XOR":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = prepareArgument(commandNum, 2);
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add(operand+" "+register1+", "+register2);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    code.add(operand+" "+register1+", "+register2);
                    registers.put(register1, command[3]);
                    inMemory.put(command[3], false);
                    break;
                }
                case "NOT":{
                    String register1 = prepareArgument(commandNum, 1);
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add(operand+" "+register1);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    code.add(operand+" "+register1);
                    registers.put(register1, command[3]);
                    inMemory.put(command[3], false);
                    break;
                }
                case "++":{
                    String register1 = prepareArgument(commandNum, 1);
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add("inc"+register1);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add("addsd "+register1+", 1");
                        floatPointRegisters.put(register1, command[3]);
                    } else {
                        code.add("inc "+register1);
                        registers.put(register1, command[3]);
                    }
                    inMemory.put(command[3], false);
                    break;
                }
                case "--":{
                    String register1 = prepareArgument(commandNum, 1);
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add("dec "+register1);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add("subsd "+register1+", 1");
                        floatPointRegisters.put(register1, command[3]);
                    } else {
                        code.add("dec "+register1);
                        registers.put(register1, command[3]);
                    }
                    inMemory.put(command[3], false);
                    break;
                }
                case "uMinus":{
                    String register1 = prepareArgument(commandNum, 1);
                    if(command[3].charAt(0) == '@'){
                        String result = "";
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add("neg "+register1);
                        if(!result.equals(register1)){
                            code.add("mov "+result+", "+register1);
                        }
                        break;
                    }
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add("xorpd "+register1+", 1");
                        floatPointRegisters.put(register1, command[3]);
                    } else {
                        code.add("neg "+register1);
                        registers.put(register1, command[3]);
                    }
                    inMemory.put(command[3], false);
                    break;
                }
                case "label":{
                    code.add(command[1]+":");
                    break;
                }
                case "goto":{
                    code.add("jmp "+command[3]);
                    break;
                }
                case "goIfFalse":{
                    String register = prepareArgument(commandNum, 1);
                    code.add("cmp "+register+", 0");
                    code.add("je "+command[3]);
                    break;
                }
                case "goIfTrue":{
                    String register = prepareArgument(commandNum, 1);
                    code.add("cmp "+register+", 0");
                    code.add("jne "+command[3]);
                    break;
                }
                case "pop":{
                    String register = prepareArgument(commandNum, 3);
                    code.add("pop "+register);
                    break;
                }
                case "push", "param":{
                    String register = prepareArgument(commandNum, 1);
                    code.add("push "+register);
                    break;
                }
                case "save":{
                    for(int i = 0; i < allRegisters.length; i++){
                        code.add("push "+allRegisters[i]);
                    }
                    for(int i = 0; i < allFloatRegisters.length; i++){
                        code.add("push "+allFloatRegisters[i]);
                    }
                    break;
                }
                case "restore":{
                    for(int i = allFloatRegisters.length-1; i >= 0; i--){
                        code.add("pop "+allFloatRegisters[i]);
                    }
                    for(int i = allRegisters.length-1; i >= 0; i--){
                        code.add("pop "+allRegisters[i]);
                    }
                    break;
                }
                case "call":{
                    code.add("call "+command[3]);
                    break;
                }
                case "return":{
                    code.add("ret");
                    break;
                }
                case "==", "!=", ">", "<", ">=", "<=":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = prepareArgument(commandNum, 2);
                    String op = "";
                    switch(operand){
                        case "==":{
                            op = "je";
                            break;
                        }
                        case "!=":{
                            op = "jne";
                            break;
                        }
                        case ">":{
                            op = "ja";
                            break;
                        }
                        case "<":{
                            op = "jb";
                            break;
                        }
                        case ">=":{
                            op = "jae";
                            break;
                        }
                        case "<=":{
                            op = "jbe";
                            break;
                        }
                    }
                    String label1 = translator.translation.newLabel();
                    String label2 = translator.translation.newLabel();
                    String result = "";
                    if(command[3].charAt(0) == '@'){
                        for(int i = 1; i < command.length; i++){
                            result += command[3].charAt(i);
                        }
                        code.add("cmp "+register1+", "+register2);
                        code.add(op+" "+label1);
                        code.add("mov "+result+", 0");
                        code.add("jmp "+label2);
                        code.add(label1+":");
                        code.add("mov "+result+", 1");
                        code.add(label2+":");
                        break;
                    }
                    result = assignRegister(commandNum, 3);
                    if(usedLater.get(commandNum).get(command[1]) && (!inMemory.containsKey(command[1]) || !inMemory.get(command[1]))){
                        saveVar(command[1]);
                    }
                    String type = translator.table.generalTypes.get(interCode.get(commandNum)[3]).name;
                    if(type.equals("double")){
                        code.add("comisd "+register1+", "+register2);
                    } else {
                        code.add("cmp "+register1+", "+register2);
                    }
                    code.add(op+" "+label1);
                    code.add("mov "+result+", 0");
                    code.add("jmp "+label2);
                    code.add(label1+":");
                    code.add("mov "+result+", 1");
                    code.add(label2+":");
                    registers.put(result, command[3]);
                    inMemory.put(command[3], false);
                    break;
                }
                case "intToLong":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = "";
                    if(command[3].charAt(0) != '@'){
                        register2 = assignRegister(commandNum, 3);
                        inMemory.put(command[3], false);
                        registers.put(register2, command[3]);
                    } else {
                        for(int i = 1; i < command[3].length(); i++){
                            register2 += command[3].charAt(i);
                        }
                    }
                    code.add("mov "+register2+", "+register1);
                    break;
                }
                case "intToDouble":{
                    String register1 = prepareArgument(commandNum, 1);
                    String register2 = "";
                    if(command[3].charAt(0) != '@'){
                        register2 = assignRegister(commandNum, 3);
                        inMemory.put(command[3], false);
                        floatPointRegisters.put(register2, command[3]);
                    } else {
                        for(int i = 1; i < command[3].length(); i++){
                            register2 += command[3].charAt(i);
                        }
                    }
                    code.add("cvtsi2sd "+register2+", "+register1);
                    break;
                }
            }
        }
        code.add("\n");
        code.add("mov RAX, 0");
        code.add("finish:");
        System.out.println("=======================================");
        for(String line : code){
            System.out.println(line);
        }
        try{
            FileWriter codeOutput = new FileWriter(targetCodeFileName);
            for(String line : code){
                codeOutput.write(line+"\n");
            }
            codeOutput.flush();
        } catch(Exception e){
            System.out.println("Class CodeGenerator:");
            System.out.println(e);
        }
        return true;
    }

    //This method analyzes the intermediate code and fills the table of usages of variables
    private void locateUsages(List<String[]> interCode){
        ArrayList<Integer> blockLeaders = (ArrayList<Integer>) findBlockLeaders(interCode);
        //List of operators, which don't use variables
        LinkedList<String> notOpList = new LinkedList<>(List.of("goto", "save", "restore", "return", "call", "label"));
        int lastCommand = interCode.size()-1;
        HashMap<String, Boolean> varUsages = new HashMap<>();
        for(Integer blockBeginning : blockLeaders){
            //List of information about future usages of variables
            for(;lastCommand >= blockBeginning; lastCommand--){
                String[] command = interCode.get(lastCommand);
                String op = command[0];
                if(notOpList.contains(op)){
                    continue;
                }
                if(op.equals("goIfTrue") || op.equals("goIfFalse")){
                    //Putting information about variables, in case this is their first usage during analysis
                    if(!varUsages.containsKey(command[1])){
                        varUsages.put(command[1], false);
                    }
                    //Saving information about usages
                    HashMap<String, Boolean> tempHashMap = new HashMap<>();
                    tempHashMap.put(command[1], varUsages.get(command[1]));
                    usedLater.put(lastCommand, tempHashMap);
                    varUsages.put(command[1], true);
                } else {
                    //Putting information about variables, in case this is their first usage during analysis
                    if(!varUsages.containsKey(command[1])){
                        varUsages.put(command[1], false);
                    }
                    if(command[2] != null && !varUsages.containsKey(command[2])){
                        varUsages.put(command[2], false);
                    }
                    if(!varUsages.containsKey(command[3])){
                        varUsages.put(command[3], false);
                    }
                    //Saving information about usages
                    HashMap<String, Boolean> tempHashMap = new HashMap<>();
                    tempHashMap.put(command[1], varUsages.get(command[1]));
                    if(command[2] != null){
                        tempHashMap.put(command[2], varUsages.get(command[2]));
                    }
                    tempHashMap.put(command[3], varUsages.get(command[3]));
                    usedLater.put(lastCommand, tempHashMap);
                    varUsages.put(command[1], true);
                    if(command[2] != null){
                        varUsages.put(command[2], true);
                    }
                    varUsages.put(command[3], false);
                }
            }
        }
    }

    //This command finds all block leaders
    private List<Integer> findBlockLeaders(List<String[]> interCode){
        List<Integer> blockLeaders = new ArrayList<>();
        //First command in code is a block leader
        blockLeaders.add(0);
        for(int commandNum = 0; commandNum < interCode.size(); commandNum++){
            String[] command = interCode.get(commandNum);
            String op = command[0];
            if(op.equals("call") || op.equals("goto") || op.equals("goIfTrue") || op.equals("goIfFalse")){
                //Command after jump is a block leader
                blockLeaders.add(commandNum+1);
                //Label to which code jumps is a block leader
                for(int i = 0; i < interCode.size(); i++){
                    if(interCode.get(i)[1] != null && interCode.get(i)[1].equals(command[3])){
                        blockLeaders.add(i);
                        break;
                    }
                }
            }
        }
        return blockLeaders;
    }

    //This method returns a register, in which this variable is currently stored
    private String getRegisterOf(String variable){
        for(String register : registers.keySet()){
            if(registers.get(register).equals(variable)){
                return register;
            }
        }
        for(String register : floatPointRegisters.keySet()){
            if(floatPointRegisters.get(register).equals(variable)){
                return register;
            }
        }
        return null;
    }

    //This method finds a register of a variable, or moves it to one, if it is only in memory
    private String prepareArgument(int commandNum, int operand){
        String register = "";
        String[] command = interCode.get(commandNum);
        if(command[operand].charAt(0) != '@'){
            register = getRegisterOf(command[operand]);
        } else {
            for(int i = 1; i < command[operand].length(); i++){
                register += command[operand].charAt(i);
            }
        }
        if(register == null){
            register = assignRegister(commandNum, operand);
            moveInRegister(command[operand], register);
        }
        return  register;
    }

    //This method assigns new register for a variable
    private String assignRegister(int commandNum, int operand){
        //Checking, if it is a float variable
        System.out.println(interCode.get(commandNum)[operand]);
        if(translator.table.generalTypes.get(interCode.get(commandNum)[operand]).name.equals("double")){
            return assignFloatRegister(commandNum, operand);
        }
        //Finding the most useless register
        ArrayList<String> freeRegisters = new ArrayList<>();
        for(String register : allRegisters){
            if(!registers.containsKey(register)){
                freeRegisters.add(register);
            }
        }
        if(!freeRegisters.isEmpty()){
            return freeRegisters.getFirst();
        }
        //Finding the best register to write value in
        ArrayList<String> notUsedRegisters = new ArrayList<>(List.of(allRegisters));
        int currentCommandNum = commandNum+1;
        LinkedList<String> notOpList = new LinkedList<>(List.of("goto", "save", "restore", "return", "call", "label"));
        while(notUsedRegisters.size() > 1 && currentCommandNum < interCode.size()){
            String[] command = interCode.get(currentCommandNum);
            String op = command[0];
            if(notOpList.contains(op)){
                currentCommandNum++;
                continue;
            }
            if(op.equals("goIfTrue") || op.equals("goIfFalse")){
                String var = command[1];
                if(registers.containsValue(var)){
                    notUsedRegisters.remove(getRegisterOf(var));
                }
                currentCommandNum++;
            } else {
                String var = command[1];
                if(var != null && registers.containsValue(var)){
                    notUsedRegisters.remove(getRegisterOf(var));
                }
                var = command[2];
                if(var != null && registers.containsValue(var)){
                    notUsedRegisters.remove(getRegisterOf(var));
                }
                currentCommandNum++;
            }
        }
        String register = notUsedRegisters.getFirst();
        String[] command = interCode.get(commandNum);
        if(usedLater.get(commandNum).get(command[operand]) && (!inMemory.containsKey(command[operand]) || !inMemory.get(command[operand]))){
            saveVar(registers.get(register));
        }
        return register;
    }

    //This method assigns new register for a variable
    private String assignFloatRegister(int commandNum, int operand){
        //Finding the most useless register
        ArrayList<String> freeRegisters = new ArrayList<>();
        for(String register : allFloatRegisters){
            if(!floatPointRegisters.containsKey(register)){
                freeRegisters.add(register);
            }
        }
        if(!freeRegisters.isEmpty()){
            return freeRegisters.getFirst();
        }
        //Finding the best register to write value in
        ArrayList<String> notUsedRegisters = new ArrayList<>(List.of(allFloatRegisters));
        int currentCommandNum = commandNum+1;
        LinkedList<String> notOpList = new LinkedList<>(List.of("goto", "save", "restore", "return", "call", "label"));
        while(notUsedRegisters.size() > 1 && currentCommandNum < interCode.size()){
            String[] command = interCode.get(currentCommandNum);
            String op = command[0];
            if(notOpList.contains(op)){
                currentCommandNum++;
                continue;
            }
            if(op.equals("goIfTrue") || op.equals("goIfFalse")){
                String var = command[1];
                if(floatPointRegisters.containsValue(var)){
                    notUsedRegisters.remove(getRegisterOf(var));
                }
                currentCommandNum++;
            } else {
                for(int i = 1; i <= 3; i++){
                    String var = command[i];
                    if(var != null && floatPointRegisters.containsValue(var)){
                        notUsedRegisters.remove(getRegisterOf(var));
                    }
                }
                currentCommandNum++;
            }
        }
        String register = notUsedRegisters.getFirst();
        String[] command = interCode.get(commandNum);
        if(usedLater.get(commandNum).get(command[operand]) && (!inMemory.containsKey(command[operand]) || !inMemory.get(command[operand]))){
            saveVar(floatPointRegisters.get(register));
        }
        return register;
    }

    //This method generates code, which transfers a value from a register to a memory cell
    private void saveVar(String var){
        String type = translator.table.generalTypes.get(var).name;
        int offsetBP = translator.table.generalAddress.get(var);
        String register = getRegisterOf(var);;
        switch (type) {
            case "long":
                code.add("mov qword [RBP-"+offsetBP+"], "+register+"q");
                break;
            case "int":
                code.add("mov dword [RBP-"+offsetBP+"], "+register+"d");
                break;
            case "bool":
                code.add("mov byte [RBP-"+offsetBP+"], "+register+"b");
                break;
            case "double":
                code.add("movq qword [RBP-"+offsetBP+"], "+register);
                break;
        }
        inMemory.put(var, true);
    }

    //This method generates code, which transfers a value from a memory cell to a register
    private void moveInRegister(String var, String register){
        String type = translator.table.generalTypes.get(var).name;
        int offsetBP = translator.table.generalAddress.get(var);
        switch (type) {
            case "long":
                code.add("mov "+register+", qword [RBP-"+offsetBP+"]");
                registers.put(register, var);
                break;
            case "int":
                code.add("movsx "+register+", dword [RBP-"+offsetBP+"]");
                registers.put(register, var);
                break;
            case "bool":
                code.add("movzx "+register+", byte [RBP-"+offsetBP+"]");
                registers.put(register, var);
                break;
            case "double":
                code.add("movq "+register+", qword [RBP-"+offsetBP+"]");
                floatPointRegisters.put(register, var);
                break;
        }
    }
}
